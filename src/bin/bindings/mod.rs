#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(dead_code)]
#![allow(non_camel_case_types)]

use serde_big_array::big_array;
big_array! { BigArray; }
use serde::{Serialize, Deserialize};
/* automatically generated by rust-bindgen */

pub const MAX_CAN_FRAME_SIZE: u32 = 64;
pub const UCAN_SERIAL_NO_SIZE: u32 = 8;
pub type FDCAN_GlobalTypeDef = u32;
pub const FunctionalState_DISABLE: FunctionalState = 0;
pub const FunctionalState_ENABLE: FunctionalState = 1;
pub type FunctionalState = u8;
pub const HAL_StatusTypeDef_HAL_OK: HAL_StatusTypeDef = 0;
pub const HAL_StatusTypeDef_HAL_ERROR: HAL_StatusTypeDef = 1;
pub const HAL_StatusTypeDef_HAL_BUSY: HAL_StatusTypeDef = 2;
pub const HAL_StatusTypeDef_HAL_TIMEOUT: HAL_StatusTypeDef = 3;
#[doc = " @brief  HAL Status structures definition"]
pub type HAL_StatusTypeDef = i32;
pub const HAL_LockTypeDef_HAL_UNLOCKED: HAL_LockTypeDef = 0;
pub const HAL_LockTypeDef_HAL_LOCKED: HAL_LockTypeDef = 1;
#[doc = " @brief  HAL Lock structures definition"]
pub type HAL_LockTypeDef = i32;
#[doc = "< FDCAN not yet initialized or disabled"]
pub const HAL_FDCAN_StateTypeDef_HAL_FDCAN_STATE_RESET: HAL_FDCAN_StateTypeDef = 0;
#[doc = "< FDCAN initialized and ready for use"]
pub const HAL_FDCAN_StateTypeDef_HAL_FDCAN_STATE_READY: HAL_FDCAN_StateTypeDef = 1;
#[doc = "< FDCAN process is ongoing"]
pub const HAL_FDCAN_StateTypeDef_HAL_FDCAN_STATE_BUSY: HAL_FDCAN_StateTypeDef = 2;
#[doc = "< FDCAN error state"]
pub const HAL_FDCAN_StateTypeDef_HAL_FDCAN_STATE_ERROR: HAL_FDCAN_StateTypeDef = 3;
#[doc = " @brief HAL State structures definition"]
pub type HAL_FDCAN_StateTypeDef = i32;
#[doc = " @brief FDCAN Init structure definition"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Serialize, Deserialize)] pub struct FDCAN_InitTypeDef {
    #[doc = "< Specifies the FDCAN kernel clock divider."]
    #[doc = "The clock is common to all FDCAN instances."]
    #[doc = "This parameter is applied only at initialisation of"]
    #[doc = "first FDCAN instance."]
    #[doc = "This parameter can be a value of @ref FDCAN_clock_divider."]
    pub ClockDivider: u32,
    #[doc = "< Specifies the FDCAN frame format."]
    #[doc = "This parameter can be a value of @ref FDCAN_frame_format"]
    pub FrameFormat: u32,
    #[doc = "< Specifies the FDCAN mode."]
    #[doc = "This parameter can be a value of @ref FDCAN_operating_mode"]
    pub Mode: u32,
    #[doc = "< Enable or disable the automatic retransmission mode."]
    #[doc = "This parameter can be set to ENABLE or DISABLE"]
    pub AutoRetransmission: FunctionalState,
    #[doc = "< Enable or disable the Transmit Pause feature."]
    #[doc = "This parameter can be set to ENABLE or DISABLE"]
    pub TransmitPause: FunctionalState,
    #[doc = "< Enable or disable the Protocol Exception Handling."]
    #[doc = "This parameter can be set to ENABLE or DISABLE"]
    pub ProtocolException: FunctionalState,
    pub PaddingInitData: u8,    
    #[doc = "< Specifies the value by which the oscillator frequency is"]
    #[doc = "divided for generating the nominal bit time quanta."]
    #[doc = "This parameter must be a number between 1 and 512"]
    pub NominalPrescaler: u32,
    #[doc = "< Specifies the maximum number of time quanta the FDCAN"]
    #[doc = "hardware is allowed to lengthen or shorten a bit to perform"]
    #[doc = "resynchronization."]
    #[doc = "This parameter must be a number between 1 and 128"]
    pub NominalSyncJumpWidth: u32,
    #[doc = "< Specifies the number of time quanta in Bit Segment 1."]
    #[doc = "This parameter must be a number between 2 and 256"]
    pub NominalTimeSeg1: u32,
    #[doc = "< Specifies the number of time quanta in Bit Segment 2."]
    #[doc = "This parameter must be a number between 2 and 128"]
    pub NominalTimeSeg2: u32,
    #[doc = "< Specifies the value by which the oscillator frequency is"]
    #[doc = "divided for generating the data bit time quanta."]
    #[doc = "This parameter must be a number between 1 and 32"]
    pub DataPrescaler: u32,
    #[doc = "< Specifies the maximum number of time quanta the FDCAN"]
    #[doc = "hardware is allowed to lengthen or shorten a data bit to"]
    #[doc = "perform resynchronization."]
    #[doc = "This parameter must be a number between 1 and 16"]
    pub DataSyncJumpWidth: u32,
    #[doc = "< Specifies the number of time quanta in Data Bit Segment 1."]
    #[doc = "This parameter must be a number between 1 and 32"]
    pub DataTimeSeg1: u32,
    #[doc = "< Specifies the number of time quanta in Data Bit Segment 2."]
    #[doc = "This parameter must be a number between 1 and 16"]
    pub DataTimeSeg2: u32,
    #[doc = "< Specifies the number of standard Message ID filters."]
    #[doc = "This parameter must be a number between 0 and 28"]
    pub StdFiltersNbr: u32,
    #[doc = "< Specifies the number of extended Message ID filters."]
    #[doc = "This parameter must be a number between 0 and 8"]
    pub ExtFiltersNbr: u32,
    #[doc = "< Tx FIFO/Queue Mode selection."]
    #[doc = "This parameter can be a value of @ref FDCAN_txFifoQueue_Mode"]
    pub TxFifoQueueMode: u32,
}
#[test]
fn bindgen_test_layout_FDCAN_InitTypeDef() {
    assert_eq!(
        ::std::mem::size_of::<FDCAN_InitTypeDef>(),
        68usize,
        concat!("Size of: ", stringify!(FDCAN_InitTypeDef))
    );
    assert_eq!(
        ::std::mem::align_of::<FDCAN_InitTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(FDCAN_InitTypeDef))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FDCAN_InitTypeDef>())).ClockDivider as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FDCAN_InitTypeDef),
            "::",
            stringify!(ClockDivider)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FDCAN_InitTypeDef>())).FrameFormat as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(FDCAN_InitTypeDef),
            "::",
            stringify!(FrameFormat)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FDCAN_InitTypeDef>())).Mode as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(FDCAN_InitTypeDef),
            "::",
            stringify!(Mode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<FDCAN_InitTypeDef>())).AutoRetransmission as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(FDCAN_InitTypeDef),
            "::",
            stringify!(AutoRetransmission)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FDCAN_InitTypeDef>())).TransmitPause as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(FDCAN_InitTypeDef),
            "::",
            stringify!(TransmitPause)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<FDCAN_InitTypeDef>())).ProtocolException as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(FDCAN_InitTypeDef),
            "::",
            stringify!(ProtocolException)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<FDCAN_InitTypeDef>())).NominalPrescaler as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(FDCAN_InitTypeDef),
            "::",
            stringify!(NominalPrescaler)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<FDCAN_InitTypeDef>())).NominalSyncJumpWidth as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(FDCAN_InitTypeDef),
            "::",
            stringify!(NominalSyncJumpWidth)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<FDCAN_InitTypeDef>())).NominalTimeSeg1 as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(FDCAN_InitTypeDef),
            "::",
            stringify!(NominalTimeSeg1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<FDCAN_InitTypeDef>())).NominalTimeSeg2 as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(FDCAN_InitTypeDef),
            "::",
            stringify!(NominalTimeSeg2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FDCAN_InitTypeDef>())).DataPrescaler as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(FDCAN_InitTypeDef),
            "::",
            stringify!(DataPrescaler)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<FDCAN_InitTypeDef>())).DataSyncJumpWidth as *const _ as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(FDCAN_InitTypeDef),
            "::",
            stringify!(DataSyncJumpWidth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FDCAN_InitTypeDef>())).DataTimeSeg1 as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(FDCAN_InitTypeDef),
            "::",
            stringify!(DataTimeSeg1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FDCAN_InitTypeDef>())).DataTimeSeg2 as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(FDCAN_InitTypeDef),
            "::",
            stringify!(DataTimeSeg2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FDCAN_InitTypeDef>())).StdFiltersNbr as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(FDCAN_InitTypeDef),
            "::",
            stringify!(StdFiltersNbr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FDCAN_InitTypeDef>())).ExtFiltersNbr as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(FDCAN_InitTypeDef),
            "::",
            stringify!(ExtFiltersNbr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<FDCAN_InitTypeDef>())).TxFifoQueueMode as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(FDCAN_InitTypeDef),
            "::",
            stringify!(TxFifoQueueMode)
        )
    );
}
#[doc = " @brief  FDCAN filter structure definition"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Serialize, Deserialize)] pub struct FDCAN_FilterTypeDef {
    #[doc = "< Specifies the identifier type."]
    #[doc = "This parameter can be a value of @ref FDCAN_id_type"]
    pub IdType: u32,
    #[doc = "< Specifies the filter which will be initialized."]
    #[doc = "This parameter must be a number between:"]
    #[doc = "- 0 and (SRAMCAN_FLS_NBR-1), if IdType is FDCAN_STANDARD_ID"]
    #[doc = "- 0 and (SRAMCAN_FLE_NBR-1), if IdType is FDCAN_EXTENDED_ID"]
    pub FilterIndex: u32,
    #[doc = "< Specifies the filter type."]
    #[doc = "This parameter can be a value of @ref FDCAN_filter_type."]
    #[doc = "The value FDCAN_FILTER_RANGE_NO_EIDM is permitted"]
    #[doc = "only when IdType is FDCAN_EXTENDED_ID."]
    pub FilterType: u32,
    #[doc = "< Specifies the filter configuration."]
    #[doc = "This parameter can be a value of @ref FDCAN_filter_config"]
    pub FilterConfig: u32,
    #[doc = "< Specifies the filter identification 1."]
    #[doc = "This parameter must be a number between:"]
    #[doc = "- 0 and 0x7FF, if IdType is FDCAN_STANDARD_ID"]
    #[doc = "- 0 and 0x1FFFFFFF, if IdType is FDCAN_EXTENDED_ID"]
    pub FilterID1: u32,
    #[doc = "< Specifies the filter identification 2."]
    #[doc = "This parameter must be a number between:"]
    #[doc = "- 0 and 0x7FF, if IdType is FDCAN_STANDARD_ID"]
    #[doc = "- 0 and 0x1FFFFFFF, if IdType is FDCAN_EXTENDED_ID"]
    pub FilterID2: u32,
}
#[test]
fn bindgen_test_layout_FDCAN_FilterTypeDef() {
    assert_eq!(
        ::std::mem::size_of::<FDCAN_FilterTypeDef>(),
        24usize,
        concat!("Size of: ", stringify!(FDCAN_FilterTypeDef))
    );
    assert_eq!(
        ::std::mem::align_of::<FDCAN_FilterTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(FDCAN_FilterTypeDef))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FDCAN_FilterTypeDef>())).IdType as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FDCAN_FilterTypeDef),
            "::",
            stringify!(IdType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FDCAN_FilterTypeDef>())).FilterIndex as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(FDCAN_FilterTypeDef),
            "::",
            stringify!(FilterIndex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FDCAN_FilterTypeDef>())).FilterType as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(FDCAN_FilterTypeDef),
            "::",
            stringify!(FilterType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<FDCAN_FilterTypeDef>())).FilterConfig as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(FDCAN_FilterTypeDef),
            "::",
            stringify!(FilterConfig)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FDCAN_FilterTypeDef>())).FilterID1 as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(FDCAN_FilterTypeDef),
            "::",
            stringify!(FilterID1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FDCAN_FilterTypeDef>())).FilterID2 as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(FDCAN_FilterTypeDef),
            "::",
            stringify!(FilterID2)
        )
    );
}
#[doc = " @brief  FDCAN Tx header structure definition"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Serialize, Deserialize)] pub struct FDCAN_TxHeaderTypeDef {
    #[doc = "< Specifies the identifier."]
    #[doc = "This parameter must be a number between:"]
    #[doc = "- 0 and 0x7FF, if IdType is FDCAN_STANDARD_ID"]
    #[doc = "- 0 and 0x1FFFFFFF, if IdType is FDCAN_EXTENDED_ID"]
    pub Identifier: u32,
    #[doc = "< Specifies the identifier type for the message that will be"]
    #[doc = "transmitted."]
    #[doc = "This parameter can be a value of @ref FDCAN_id_type"]
    pub IdType: u32,
    #[doc = "< Specifies the frame type of the message that will be transmitted."]
    #[doc = "This parameter can be a value of @ref FDCAN_frame_type"]
    pub TxFrameType: u32,
    #[doc = "< Specifies the length of the frame that will be transmitted."]
    #[doc = "This parameter can be a value of @ref FDCAN_data_length_code"]
    pub DataLength: u32,
    #[doc = "< Specifies the error state indicator."]
    #[doc = "This parameter can be a value of @ref FDCAN_error_state_indicator"]
    pub ErrorStateIndicator: u32,
    #[doc = "< Specifies whether the Tx frame will be transmitted with or without"]
    #[doc = "bit rate switching."]
    #[doc = "This parameter can be a value of @ref FDCAN_bit_rate_switching"]
    pub BitRateSwitch: u32,
    #[doc = "< Specifies whether the Tx frame will be transmitted in classic or"]
    #[doc = "FD format."]
    #[doc = "This parameter can be a value of @ref FDCAN_format"]
    pub FDFormat: u32,
    #[doc = "< Specifies the event FIFO control."]
    #[doc = "This parameter can be a value of @ref FDCAN_EFC"]
    pub TxEventFifoControl: u32,
    #[doc = "< Specifies the message marker to be copied into Tx Event FIFO"]
    #[doc = "element for identification of Tx message status."]
    #[doc = "This parameter must be a number between 0 and 0xFF"]
    pub MessageMarker: u32,
}
#[test]
fn bindgen_test_layout_FDCAN_TxHeaderTypeDef() {
    assert_eq!(
        ::std::mem::size_of::<FDCAN_TxHeaderTypeDef>(),
        36usize,
        concat!("Size of: ", stringify!(FDCAN_TxHeaderTypeDef))
    );
    assert_eq!(
        ::std::mem::align_of::<FDCAN_TxHeaderTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(FDCAN_TxHeaderTypeDef))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<FDCAN_TxHeaderTypeDef>())).Identifier as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FDCAN_TxHeaderTypeDef),
            "::",
            stringify!(Identifier)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FDCAN_TxHeaderTypeDef>())).IdType as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(FDCAN_TxHeaderTypeDef),
            "::",
            stringify!(IdType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<FDCAN_TxHeaderTypeDef>())).TxFrameType as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(FDCAN_TxHeaderTypeDef),
            "::",
            stringify!(TxFrameType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<FDCAN_TxHeaderTypeDef>())).DataLength as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(FDCAN_TxHeaderTypeDef),
            "::",
            stringify!(DataLength)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<FDCAN_TxHeaderTypeDef>())).ErrorStateIndicator as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(FDCAN_TxHeaderTypeDef),
            "::",
            stringify!(ErrorStateIndicator)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<FDCAN_TxHeaderTypeDef>())).BitRateSwitch as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(FDCAN_TxHeaderTypeDef),
            "::",
            stringify!(BitRateSwitch)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FDCAN_TxHeaderTypeDef>())).FDFormat as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(FDCAN_TxHeaderTypeDef),
            "::",
            stringify!(FDFormat)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<FDCAN_TxHeaderTypeDef>())).TxEventFifoControl as *const _
                as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(FDCAN_TxHeaderTypeDef),
            "::",
            stringify!(TxEventFifoControl)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<FDCAN_TxHeaderTypeDef>())).MessageMarker as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(FDCAN_TxHeaderTypeDef),
            "::",
            stringify!(MessageMarker)
        )
    );
}
#[doc = " @brief  FDCAN Rx header structure definition"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Serialize, Deserialize)] pub struct FDCAN_RxHeaderTypeDef {
    #[doc = "< Specifies the identifier."]
    #[doc = "This parameter must be a number between:"]
    #[doc = "- 0 and 0x7FF, if IdType is FDCAN_STANDARD_ID"]
    #[doc = "- 0 and 0x1FFFFFFF, if IdType is FDCAN_EXTENDED_ID"]
    pub Identifier: u32,
    #[doc = "< Specifies the identifier type of the received message."]
    #[doc = "This parameter can be a value of @ref FDCAN_id_type"]
    pub IdType: u32,
    #[doc = "< Specifies the the received message frame type."]
    #[doc = "This parameter can be a value of @ref FDCAN_frame_type"]
    pub RxFrameType: u32,
    #[doc = "< Specifies the received frame length."]
    #[doc = "This parameter can be a value of @ref FDCAN_data_length_code"]
    pub DataLength: u32,
    #[doc = "< Specifies the error state indicator."]
    #[doc = "This parameter can be a value of @ref FDCAN_error_state_indicator"]
    pub ErrorStateIndicator: u32,
    #[doc = "< Specifies whether the Rx frame is received with or without bit"]
    #[doc = "rate switching."]
    #[doc = "This parameter can be a value of @ref FDCAN_bit_rate_switching"]
    pub BitRateSwitch: u32,
    #[doc = "< Specifies whether the Rx frame is received in classic or FD"]
    #[doc = "format."]
    #[doc = "This parameter can be a value of @ref FDCAN_format"]
    pub FDFormat: u32,
    #[doc = "< Specifies the timestamp counter value captured on start of frame"]
    #[doc = "reception."]
    #[doc = "This parameter must be a number between 0 and 0xFFFF"]
    pub RxTimestamp: u32,
    #[doc = "< Specifies the index of matching Rx acceptance filter element."]
    #[doc = "This parameter must be a number between:"]
    #[doc = "- 0 and (SRAMCAN_FLS_NBR-1), if IdType is FDCAN_STANDARD_ID"]
    #[doc = "- 0 and (SRAMCAN_FLE_NBR-1), if IdType is FDCAN_EXTENDED_ID"]
    pub FilterIndex: u32,
    #[doc = "< Specifies whether the accepted frame did not match any Rx filter."]
    #[doc = "Acceptance of non-matching frames may be enabled via"]
    #[doc = "HAL_FDCAN_ConfigGlobalFilter()."]
    #[doc = "This parameter can be 0 or 1"]
    pub IsFilterMatchingFrame: u32,
}
#[test]
fn bindgen_test_layout_FDCAN_RxHeaderTypeDef() {
    assert_eq!(
        ::std::mem::size_of::<FDCAN_RxHeaderTypeDef>(),
        40usize,
        concat!("Size of: ", stringify!(FDCAN_RxHeaderTypeDef))
    );
    assert_eq!(
        ::std::mem::align_of::<FDCAN_RxHeaderTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(FDCAN_RxHeaderTypeDef))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<FDCAN_RxHeaderTypeDef>())).Identifier as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FDCAN_RxHeaderTypeDef),
            "::",
            stringify!(Identifier)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FDCAN_RxHeaderTypeDef>())).IdType as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(FDCAN_RxHeaderTypeDef),
            "::",
            stringify!(IdType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<FDCAN_RxHeaderTypeDef>())).RxFrameType as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(FDCAN_RxHeaderTypeDef),
            "::",
            stringify!(RxFrameType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<FDCAN_RxHeaderTypeDef>())).DataLength as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(FDCAN_RxHeaderTypeDef),
            "::",
            stringify!(DataLength)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<FDCAN_RxHeaderTypeDef>())).ErrorStateIndicator as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(FDCAN_RxHeaderTypeDef),
            "::",
            stringify!(ErrorStateIndicator)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<FDCAN_RxHeaderTypeDef>())).BitRateSwitch as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(FDCAN_RxHeaderTypeDef),
            "::",
            stringify!(BitRateSwitch)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FDCAN_RxHeaderTypeDef>())).FDFormat as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(FDCAN_RxHeaderTypeDef),
            "::",
            stringify!(FDFormat)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<FDCAN_RxHeaderTypeDef>())).RxTimestamp as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(FDCAN_RxHeaderTypeDef),
            "::",
            stringify!(RxTimestamp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<FDCAN_RxHeaderTypeDef>())).FilterIndex as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(FDCAN_RxHeaderTypeDef),
            "::",
            stringify!(FilterIndex)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<FDCAN_RxHeaderTypeDef>())).IsFilterMatchingFrame as *const _
                as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(FDCAN_RxHeaderTypeDef),
            "::",
            stringify!(IsFilterMatchingFrame)
        )
    );
}
#[doc = " @brief  FDCAN Tx event FIFO structure definition"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Serialize, Deserialize)] pub struct FDCAN_TxEventFifoTypeDef {
    #[doc = "< Specifies the identifier."]
    #[doc = "This parameter must be a number between:"]
    #[doc = "- 0 and 0x7FF, if IdType is FDCAN_STANDARD_ID"]
    #[doc = "- 0 and 0x1FFFFFFF, if IdType is FDCAN_EXTENDED_ID"]
    pub Identifier: u32,
    #[doc = "< Specifies the identifier type for the transmitted message."]
    #[doc = "This parameter can be a value of @ref FDCAN_id_type"]
    pub IdType: u32,
    #[doc = "< Specifies the frame type of the transmitted message."]
    #[doc = "This parameter can be a value of @ref FDCAN_frame_type"]
    pub TxFrameType: u32,
    #[doc = "< Specifies the length of the transmitted frame."]
    #[doc = "This parameter can be a value of @ref FDCAN_data_length_code"]
    pub DataLength: u32,
    #[doc = "< Specifies the error state indicator."]
    #[doc = "This parameter can be a value of @ref FDCAN_error_state_indicator"]
    pub ErrorStateIndicator: u32,
    #[doc = "< Specifies whether the Tx frame is transmitted with or without bit"]
    #[doc = "rate switching."]
    #[doc = "This parameter can be a value of @ref FDCAN_bit_rate_switching"]
    pub BitRateSwitch: u32,
    #[doc = "< Specifies whether the Tx frame is transmitted in classic or FD"]
    #[doc = "format."]
    #[doc = "This parameter can be a value of @ref FDCAN_format"]
    pub FDFormat: u32,
    #[doc = "< Specifies the timestamp counter value captured on start of frame"]
    #[doc = "transmission."]
    #[doc = "This parameter must be a number between 0 and 0xFFFF"]
    pub TxTimestamp: u32,
    #[doc = "< Specifies the message marker copied into Tx Event FIFO element"]
    #[doc = "for identification of Tx message status."]
    #[doc = "This parameter must be a number between 0 and 0xFF"]
    pub MessageMarker: u32,
    #[doc = "< Specifies the event type."]
    #[doc = "This parameter can be a value of @ref FDCAN_event_type"]
    pub EventType: u32,
}
#[test]
fn bindgen_test_layout_FDCAN_TxEventFifoTypeDef() {
    assert_eq!(
        ::std::mem::size_of::<FDCAN_TxEventFifoTypeDef>(),
        40usize,
        concat!("Size of: ", stringify!(FDCAN_TxEventFifoTypeDef))
    );
    assert_eq!(
        ::std::mem::align_of::<FDCAN_TxEventFifoTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(FDCAN_TxEventFifoTypeDef))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<FDCAN_TxEventFifoTypeDef>())).Identifier as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FDCAN_TxEventFifoTypeDef),
            "::",
            stringify!(Identifier)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FDCAN_TxEventFifoTypeDef>())).IdType as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(FDCAN_TxEventFifoTypeDef),
            "::",
            stringify!(IdType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<FDCAN_TxEventFifoTypeDef>())).TxFrameType as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(FDCAN_TxEventFifoTypeDef),
            "::",
            stringify!(TxFrameType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<FDCAN_TxEventFifoTypeDef>())).DataLength as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(FDCAN_TxEventFifoTypeDef),
            "::",
            stringify!(DataLength)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<FDCAN_TxEventFifoTypeDef>())).ErrorStateIndicator as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(FDCAN_TxEventFifoTypeDef),
            "::",
            stringify!(ErrorStateIndicator)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<FDCAN_TxEventFifoTypeDef>())).BitRateSwitch as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(FDCAN_TxEventFifoTypeDef),
            "::",
            stringify!(BitRateSwitch)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<FDCAN_TxEventFifoTypeDef>())).FDFormat as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(FDCAN_TxEventFifoTypeDef),
            "::",
            stringify!(FDFormat)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<FDCAN_TxEventFifoTypeDef>())).TxTimestamp as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(FDCAN_TxEventFifoTypeDef),
            "::",
            stringify!(TxTimestamp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<FDCAN_TxEventFifoTypeDef>())).MessageMarker as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(FDCAN_TxEventFifoTypeDef),
            "::",
            stringify!(MessageMarker)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<FDCAN_TxEventFifoTypeDef>())).EventType as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(FDCAN_TxEventFifoTypeDef),
            "::",
            stringify!(EventType)
        )
    );
}
#[doc = " @brief  FDCAN High Priority Message Status structure definition"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Serialize, Deserialize)] pub struct FDCAN_HpMsgStatusTypeDef {
    #[doc = "< Specifies the filter list of the matching filter element."]
    #[doc = "This parameter can be:"]
    #[doc = "- 0 : Standard Filter List"]
    #[doc = "- 1 : Extended Filter List"]
    pub FilterList: u32,
    #[doc = "< Specifies the index of matching filter element."]
    #[doc = "This parameter can be a number between:"]
    #[doc = "- 0 and (SRAMCAN_FLS_NBR-1), if FilterList is 0 (Standard)"]
    #[doc = "- 0 and (SRAMCAN_FLE_NBR-1), if FilterList is 1 (Extended)"]
    pub FilterIndex: u32,
    #[doc = "< Specifies the HP Message Storage."]
    #[doc = "This parameter can be a value of @ref FDCAN_hp_msg_storage"]
    pub MessageStorage: u32,
    #[doc = "< Specifies the Index of Rx FIFO element to which the"]
    #[doc = "message was stored."]
    #[doc = "This parameter is valid only when MessageStorage is:"]
    #[doc = "FDCAN_HP_STORAGE_RXFIFO0"]
    #[doc = "or"]
    #[doc = "FDCAN_HP_STORAGE_RXFIFO1"]
    pub MessageIndex: u32,
}
#[test]
fn bindgen_test_layout_FDCAN_HpMsgStatusTypeDef() {
    assert_eq!(
        ::std::mem::size_of::<FDCAN_HpMsgStatusTypeDef>(),
        16usize,
        concat!("Size of: ", stringify!(FDCAN_HpMsgStatusTypeDef))
    );
    assert_eq!(
        ::std::mem::align_of::<FDCAN_HpMsgStatusTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(FDCAN_HpMsgStatusTypeDef))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<FDCAN_HpMsgStatusTypeDef>())).FilterList as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FDCAN_HpMsgStatusTypeDef),
            "::",
            stringify!(FilterList)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<FDCAN_HpMsgStatusTypeDef>())).FilterIndex as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(FDCAN_HpMsgStatusTypeDef),
            "::",
            stringify!(FilterIndex)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<FDCAN_HpMsgStatusTypeDef>())).MessageStorage as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(FDCAN_HpMsgStatusTypeDef),
            "::",
            stringify!(MessageStorage)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<FDCAN_HpMsgStatusTypeDef>())).MessageIndex as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(FDCAN_HpMsgStatusTypeDef),
            "::",
            stringify!(MessageIndex)
        )
    );
}
#[doc = " @brief FDCAN Protocol Status structure definition"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Serialize, Deserialize)] pub struct FDCAN_ProtocolStatusTypeDef {
    #[doc = "< Specifies the type of the last error that occurred on the FDCAN bus."]
    #[doc = "This parameter can be a value of @ref FDCAN_protocol_error_code"]
    pub LastErrorCode: u32,
    #[doc = "< Specifies the type of the last error that occurred in the data phase of a CAN FD format"]
    #[doc = "frame with its BRS flag set."]
    #[doc = "This parameter can be a value of @ref FDCAN_protocol_error_code"]
    pub DataLastErrorCode: u32,
    #[doc = "< Specifies the FDCAN module communication state."]
    #[doc = "This parameter can be a value of @ref FDCAN_communication_state"]
    pub Activity: u32,
    #[doc = "< Specifies the FDCAN module error status."]
    #[doc = "This parameter can be:"]
    #[doc = "- 0 : The FDCAN is in Error_Active state"]
    #[doc = "- 1 : The FDCAN is in Error_Passive state"]
    pub ErrorPassive: u32,
    #[doc = "< Specifies the FDCAN module warning status."]
    #[doc = "This parameter can be:"]
    #[doc = "- 0 : error counters (RxErrorCnt and TxErrorCnt) are below the Error_Warning limit of 96"]
    #[doc = "- 1 : at least one of error counters has reached the Error_Warning limit of 96"]
    pub Warning: u32,
    #[doc = "< Specifies the FDCAN module Bus_Off status."]
    #[doc = "This parameter can be:"]
    #[doc = "- 0 : The FDCAN is not in Bus_Off state"]
    #[doc = "- 1 : The FDCAN is in Bus_Off state"]
    pub BusOff: u32,
    #[doc = "< Specifies ESI flag of last received CAN FD message."]
    #[doc = "This parameter can be:"]
    #[doc = "- 0 : Last received CAN FD message did not have its ESI flag set"]
    #[doc = "- 1 : Last received CAN FD message had its ESI flag set"]
    pub RxESIflag: u32,
    #[doc = "< Specifies BRS flag of last received CAN FD message."]
    #[doc = "This parameter can be:"]
    #[doc = "- 0 : Last received CAN FD message did not have its BRS flag set"]
    #[doc = "- 1 : Last received CAN FD message had its BRS flag set"]
    pub RxBRSflag: u32,
    #[doc = "< Specifies if CAN FD message (FDF flag set) has been received since last protocol status"]
    #[doc = "This parameter can be:"]
    #[doc = "- 0 : No CAN FD message received"]
    #[doc = "- 1 : CAN FD message received"]
    pub RxFDFflag: u32,
    #[doc = "< Specifies the FDCAN module Protocol Exception status."]
    #[doc = "This parameter can be:"]
    #[doc = "- 0 : No protocol exception event occurred since last read access"]
    #[doc = "- 1 : Protocol exception event occurred"]
    pub ProtocolException: u32,
    #[doc = "< Specifies the Transmitter Delay Compensation Value."]
    #[doc = "This parameter can be a number between 0 and 127"]
    pub TDCvalue: u32,
}
#[test]
fn bindgen_test_layout_FDCAN_ProtocolStatusTypeDef() {
    assert_eq!(
        ::std::mem::size_of::<FDCAN_ProtocolStatusTypeDef>(),
        44usize,
        concat!("Size of: ", stringify!(FDCAN_ProtocolStatusTypeDef))
    );
    assert_eq!(
        ::std::mem::align_of::<FDCAN_ProtocolStatusTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(FDCAN_ProtocolStatusTypeDef))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<FDCAN_ProtocolStatusTypeDef>())).LastErrorCode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FDCAN_ProtocolStatusTypeDef),
            "::",
            stringify!(LastErrorCode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<FDCAN_ProtocolStatusTypeDef>())).DataLastErrorCode as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(FDCAN_ProtocolStatusTypeDef),
            "::",
            stringify!(DataLastErrorCode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<FDCAN_ProtocolStatusTypeDef>())).Activity as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(FDCAN_ProtocolStatusTypeDef),
            "::",
            stringify!(Activity)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<FDCAN_ProtocolStatusTypeDef>())).ErrorPassive as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(FDCAN_ProtocolStatusTypeDef),
            "::",
            stringify!(ErrorPassive)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<FDCAN_ProtocolStatusTypeDef>())).Warning as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(FDCAN_ProtocolStatusTypeDef),
            "::",
            stringify!(Warning)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<FDCAN_ProtocolStatusTypeDef>())).BusOff as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(FDCAN_ProtocolStatusTypeDef),
            "::",
            stringify!(BusOff)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<FDCAN_ProtocolStatusTypeDef>())).RxESIflag as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(FDCAN_ProtocolStatusTypeDef),
            "::",
            stringify!(RxESIflag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<FDCAN_ProtocolStatusTypeDef>())).RxBRSflag as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(FDCAN_ProtocolStatusTypeDef),
            "::",
            stringify!(RxBRSflag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<FDCAN_ProtocolStatusTypeDef>())).RxFDFflag as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(FDCAN_ProtocolStatusTypeDef),
            "::",
            stringify!(RxFDFflag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<FDCAN_ProtocolStatusTypeDef>())).ProtocolException as *const _
                as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(FDCAN_ProtocolStatusTypeDef),
            "::",
            stringify!(ProtocolException)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<FDCAN_ProtocolStatusTypeDef>())).TDCvalue as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(FDCAN_ProtocolStatusTypeDef),
            "::",
            stringify!(TDCvalue)
        )
    );
}
#[doc = " @brief FDCAN Error Counters structure definition"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Serialize, Deserialize)] pub struct FDCAN_ErrorCountersTypeDef {
    #[doc = "< Specifies the Transmit Error Counter Value."]
    #[doc = "This parameter can be a number between 0 and 255"]
    pub TxErrorCnt: u32,
    #[doc = "< Specifies the Receive Error Counter Value."]
    #[doc = "This parameter can be a number between 0 and 127"]
    pub RxErrorCnt: u32,
    #[doc = "< Specifies the Receive Error Passive status."]
    #[doc = "This parameter can be:"]
    #[doc = "- 0 : The Receive Error Counter (RxErrorCnt) is below the error passive level of 128"]
    #[doc = "- 1 : The Receive Error Counter (RxErrorCnt) has reached the error passive level of 128"]
    pub RxErrorPassive: u32,
    #[doc = "< Specifies the Transmit/Receive error logging counter value."]
    #[doc = "This parameter can be a number between 0 and 255."]
    #[doc = "This counter is incremented each time when a FDCAN protocol error causes the TxErrorCnt"]
    #[doc = "or the RxErrorCnt to be incremented. The counter stops at 255; the next increment of"]
    #[doc = "TxErrorCnt or RxErrorCnt sets interrupt flag FDCAN_FLAG_ERROR_LOGGING_OVERFLOW"]
    pub ErrorLogging: u32,
}
#[test]
fn bindgen_test_layout_FDCAN_ErrorCountersTypeDef() {
    assert_eq!(
        ::std::mem::size_of::<FDCAN_ErrorCountersTypeDef>(),
        16usize,
        concat!("Size of: ", stringify!(FDCAN_ErrorCountersTypeDef))
    );
    assert_eq!(
        ::std::mem::align_of::<FDCAN_ErrorCountersTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(FDCAN_ErrorCountersTypeDef))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<FDCAN_ErrorCountersTypeDef>())).TxErrorCnt as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FDCAN_ErrorCountersTypeDef),
            "::",
            stringify!(TxErrorCnt)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<FDCAN_ErrorCountersTypeDef>())).RxErrorCnt as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(FDCAN_ErrorCountersTypeDef),
            "::",
            stringify!(RxErrorCnt)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<FDCAN_ErrorCountersTypeDef>())).RxErrorPassive as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(FDCAN_ErrorCountersTypeDef),
            "::",
            stringify!(RxErrorPassive)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<FDCAN_ErrorCountersTypeDef>())).ErrorLogging as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(FDCAN_ErrorCountersTypeDef),
            "::",
            stringify!(ErrorLogging)
        )
    );
}
#[doc = " @brief  FDCAN Message RAM blocks"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Serialize, Deserialize)] pub struct FDCAN_MsgRamAddressTypeDef {
    #[doc = "< Specifies the Standard Filter List Start Address."]
    #[doc = "This parameter must be a 32-bit word address"]
    pub StandardFilterSA: u32,
    #[doc = "< Specifies the Extended Filter List Start Address."]
    #[doc = "This parameter must be a 32-bit word address"]
    pub ExtendedFilterSA: u32,
    #[doc = "< Specifies the Rx FIFO 0 Start Address."]
    #[doc = "This parameter must be a 32-bit word address"]
    pub RxFIFO0SA: u32,
    #[doc = "< Specifies the Rx FIFO 1 Start Address."]
    #[doc = "This parameter must be a 32-bit word address"]
    pub RxFIFO1SA: u32,
    #[doc = "< Specifies the Tx Event FIFO Start Address."]
    #[doc = "This parameter must be a 32-bit word address"]
    pub TxEventFIFOSA: u32,
    #[doc = "< Specifies the Tx FIFO/Queue Start Address."]
    #[doc = "This parameter must be a 32-bit word address"]
    pub TxFIFOQSA: u32,
}
#[test]
fn bindgen_test_layout_FDCAN_MsgRamAddressTypeDef() {
    assert_eq!(
        ::std::mem::size_of::<FDCAN_MsgRamAddressTypeDef>(),
        24usize,
        concat!("Size of: ", stringify!(FDCAN_MsgRamAddressTypeDef))
    );
    assert_eq!(
        ::std::mem::align_of::<FDCAN_MsgRamAddressTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(FDCAN_MsgRamAddressTypeDef))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<FDCAN_MsgRamAddressTypeDef>())).StandardFilterSA as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FDCAN_MsgRamAddressTypeDef),
            "::",
            stringify!(StandardFilterSA)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<FDCAN_MsgRamAddressTypeDef>())).ExtendedFilterSA as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(FDCAN_MsgRamAddressTypeDef),
            "::",
            stringify!(ExtendedFilterSA)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<FDCAN_MsgRamAddressTypeDef>())).RxFIFO0SA as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(FDCAN_MsgRamAddressTypeDef),
            "::",
            stringify!(RxFIFO0SA)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<FDCAN_MsgRamAddressTypeDef>())).RxFIFO1SA as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(FDCAN_MsgRamAddressTypeDef),
            "::",
            stringify!(RxFIFO1SA)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<FDCAN_MsgRamAddressTypeDef>())).TxEventFIFOSA as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(FDCAN_MsgRamAddressTypeDef),
            "::",
            stringify!(TxEventFIFOSA)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<FDCAN_MsgRamAddressTypeDef>())).TxFIFOQSA as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(FDCAN_MsgRamAddressTypeDef),
            "::",
            stringify!(TxFIFOQSA)
        )
    );
}
#[doc = "< init CAN with all parameters, open in mode specified in init data. Frame direction USB->CAN"]
pub const UCAN_FRAME_TYPE_UCAN_FD_INIT: UCAN_FRAME_TYPE = 0;
#[doc = "< deinit CAN, close CAN connection. Frame direction USB->CAN"]
pub const UCAN_FRAME_TYPE_UCAN_FD_DEINIT: UCAN_FRAME_TYPE = 1;
#[doc = "< send new frame on CAN network. Frame direction USB->CAN"]
pub const UCAN_FRAME_TYPE_UCAN_FD_TX: UCAN_FRAME_TYPE = 2;
#[doc = "< saves CAN config to NVM USB->CAN"]
pub const UCAN_FRAME_TYPE_UCAN_FD_SAVE_CONFIG: UCAN_FRAME_TYPE = 3;
#[doc = "< go to USB bootloader USB->CAN"]
pub const UCAN_FRAME_TYPE_UCAN_FD_GO_TO_BOOTLOADER: UCAN_FRAME_TYPE = 4;
#[doc = "< request status USB->CAN"]
pub const UCAN_FRAME_TYPE_UCAN_FD_GET_CAN_STATUS: UCAN_FRAME_TYPE = 5;
#[doc = "< new CAN frame received on network. Frame direction CAN->USB"]
pub const UCAN_FRAME_TYPE_UCAN_FD_RX: UCAN_FRAME_TYPE = 6;
#[doc = "< gets CAN status from CONVERTER. Also ACK resposne for all frames form USB. Frame direction CAN->USB"]
pub const UCAN_FRAME_TYPE_UCAN_FD_ACK: UCAN_FRAME_TYPE = 7;
pub const UCAN_FRAME_TYPE_ENUM_SIZE_GUARD: UCAN_FRAME_TYPE = -1;
#[doc = " @brief List all Frames on CAN <-> USB protocol"]
pub type UCAN_FRAME_TYPE = i32;
#[doc = "< command was executed successfully USB->CAN"]
pub const UCAN_FRAME_CMD_STATUS_UCAN_FD_COMMAND_OK: UCAN_FRAME_CMD_STATUS = 0;
#[doc = "< command was not executed see error code"]
pub const UCAN_FRAME_CMD_STATUS_UCAN_FD_COMMAND_ERROR: UCAN_FRAME_CMD_STATUS = 1;
#[doc = "< wrong param"]
pub const UCAN_FRAME_CMD_STATUS_UCAN_FD_COMMAND_WRONG_PARAM: UCAN_FRAME_CMD_STATUS = 2;
pub type UCAN_FRAME_CMD_STATUS = i32;
pub const UCAN_DEV_TYPE_UCAN_CAN_FD: UCAN_DEV_TYPE = 0;
pub const UCAN_DEV_TYPE_UCAN_CAN_HS: UCAN_DEV_TYPE = 1;
pub const UCAN_DEV_TYPE_UCAN_LIN: UCAN_DEV_TYPE = 2;
pub type UCAN_DEV_TYPE = i32;
#[doc = " @brief Device version and serial number"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Serialize, Deserialize)] pub struct FDCAN_Device_DescritionDef {
    #[doc = "< software version"]
    pub sw_version: u8,
    #[doc = "< hardware version"]
    pub hw_version: u8,
    #[doc = "< device type"]
    pub dev_type: UCAN_DEV_TYPE,
    #[doc = "< device serial number"]
    pub serial_number: [u8; 8usize],
}
#[test]
fn bindgen_test_layout_FDCAN_Device_DescritionDef() {
    assert_eq!(
        ::std::mem::size_of::<FDCAN_Device_DescritionDef>(),
        16usize,
        concat!("Size of: ", stringify!(FDCAN_Device_DescritionDef))
    );
    assert_eq!(
        ::std::mem::align_of::<FDCAN_Device_DescritionDef>(),
        4usize,
        concat!("Alignment of ", stringify!(FDCAN_Device_DescritionDef))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<FDCAN_Device_DescritionDef>())).sw_version as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FDCAN_Device_DescritionDef),
            "::",
            stringify!(sw_version)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<FDCAN_Device_DescritionDef>())).hw_version as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(FDCAN_Device_DescritionDef),
            "::",
            stringify!(hw_version)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<FDCAN_Device_DescritionDef>())).dev_type as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(FDCAN_Device_DescritionDef),
            "::",
            stringify!(dev_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<FDCAN_Device_DescritionDef>())).serial_number as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(FDCAN_Device_DescritionDef),
            "::",
            stringify!(serial_number)
        )
    );
}
#[doc = " @brief UCAN_FD_INIT frame structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Serialize, Deserialize)] pub struct UCAN_InitFrameDef {
    #[doc = "< Frame type is @ref UCAN_FD_INIT."]
    pub frame_type: UCAN_FRAME_TYPE,
    #[doc = "< FDCAN Init structure definition @ref FDCAN_InitTypeDef."]
    pub can_init: FDCAN_InitTypeDef,
}
#[test]
fn bindgen_test_layout_UCAN_InitFrameDef() {
    assert_eq!(
        ::std::mem::size_of::<UCAN_InitFrameDef>(),
        72usize,
        concat!("Size of: ", stringify!(UCAN_InitFrameDef))
    );
    assert_eq!(
        ::std::mem::align_of::<UCAN_InitFrameDef>(),
        4usize,
        concat!("Alignment of ", stringify!(UCAN_InitFrameDef))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UCAN_InitFrameDef>())).frame_type as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(UCAN_InitFrameDef),
            "::",
            stringify!(frame_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UCAN_InitFrameDef>())).can_init as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(UCAN_InitFrameDef),
            "::",
            stringify!(can_init)
        )
    );
}
#[doc = " @brief UCAN_FD_DEINIT frame structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Serialize, Deserialize)] pub struct UCAN_DeinitFrameDef {
    #[doc = "< Frame type is @ref UCAN_FD_DEINIT."]
    pub frame_type: UCAN_FRAME_TYPE,
}
#[test]
fn bindgen_test_layout_UCAN_DeinitFrameDef() {
    assert_eq!(
        ::std::mem::size_of::<UCAN_DeinitFrameDef>(),
        4usize,
        concat!("Size of: ", stringify!(UCAN_DeinitFrameDef))
    );
    assert_eq!(
        ::std::mem::align_of::<UCAN_DeinitFrameDef>(),
        4usize,
        concat!("Alignment of ", stringify!(UCAN_DeinitFrameDef))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UCAN_DeinitFrameDef>())).frame_type as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(UCAN_DeinitFrameDef),
            "::",
            stringify!(frame_type)
        )
    );
}
#[doc = " @brief UCAN_FD_TX frame structure"]
#[repr(C)]
#[derive(Copy, Clone, Serialize, Deserialize)] pub struct UCAN_TxFrameDef {
    #[doc = "< Frame type is @ref UCAN_FD_TX."]
    pub frame_type: UCAN_FRAME_TYPE,
    #[doc = "< FDCAN Tx event FIFO structure definition @ref FDCAN_TxHeaderTypeDef."]
    pub can_tx_header: FDCAN_TxHeaderTypeDef,
     #[serde(with = "BigArray")]
 pub can_data: [u8; 64usize], 
}
#[test]
fn bindgen_test_layout_UCAN_TxFrameDef() {
    assert_eq!(
        ::std::mem::size_of::<UCAN_TxFrameDef>(),
        108usize,
        concat!("Size of: ", stringify!(UCAN_TxFrameDef))
    );
    assert_eq!(
        ::std::mem::align_of::<UCAN_TxFrameDef>(),
        4usize,
        concat!("Alignment of ", stringify!(UCAN_TxFrameDef))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UCAN_TxFrameDef>())).frame_type as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(UCAN_TxFrameDef),
            "::",
            stringify!(frame_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UCAN_TxFrameDef>())).can_tx_header as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(UCAN_TxFrameDef),
            "::",
            stringify!(can_tx_header)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UCAN_TxFrameDef>())).can_data as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(UCAN_TxFrameDef),
            "::",
            stringify!(can_data)
        )
    );
}
#[doc = " @brief UCAN_FD_SAVE_CONFIG frame structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Serialize, Deserialize)] pub struct UCAN_SaveConfigFrameDef {
    #[doc = "< Frame type is @ref UCAN_FD_SAVE_CONFIG."]
    pub frame_type: UCAN_FRAME_TYPE,
}
#[test]
fn bindgen_test_layout_UCAN_SaveConfigFrameDef() {
    assert_eq!(
        ::std::mem::size_of::<UCAN_SaveConfigFrameDef>(),
        4usize,
        concat!("Size of: ", stringify!(UCAN_SaveConfigFrameDef))
    );
    assert_eq!(
        ::std::mem::align_of::<UCAN_SaveConfigFrameDef>(),
        4usize,
        concat!("Alignment of ", stringify!(UCAN_SaveConfigFrameDef))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<UCAN_SaveConfigFrameDef>())).frame_type as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(UCAN_SaveConfigFrameDef),
            "::",
            stringify!(frame_type)
        )
    );
}
#[doc = " @brief UCAN_FD_GO_TO_BOOTLOADER frame structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Serialize, Deserialize)] pub struct UCAN_GoToBootladerFrameDef {
    #[doc = "< Frame type is @ref UCAN_FD_GO_TO_BOOTLOADER."]
    pub frame_type: UCAN_FRAME_TYPE,
}
#[test]
fn bindgen_test_layout_UCAN_GoToBootladerFrameDef() {
    assert_eq!(
        ::std::mem::size_of::<UCAN_GoToBootladerFrameDef>(),
        4usize,
        concat!("Size of: ", stringify!(UCAN_GoToBootladerFrameDef))
    );
    assert_eq!(
        ::std::mem::align_of::<UCAN_GoToBootladerFrameDef>(),
        4usize,
        concat!("Alignment of ", stringify!(UCAN_GoToBootladerFrameDef))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<UCAN_GoToBootladerFrameDef>())).frame_type as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(UCAN_GoToBootladerFrameDef),
            "::",
            stringify!(frame_type)
        )
    );
}
#[doc = " @brief UCAN_FD_GET_CAN_STATUS frame structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Serialize, Deserialize)] pub struct UCAN_Get_CAN_Status {
    #[doc = "< Frame type is @ref UCAN_FD_GET_CAN_STATUS."]
    pub frame_type: UCAN_FRAME_TYPE,
}
#[test]
fn bindgen_test_layout_UCAN_Get_CAN_Status() {
    assert_eq!(
        ::std::mem::size_of::<UCAN_Get_CAN_Status>(),
        4usize,
        concat!("Size of: ", stringify!(UCAN_Get_CAN_Status))
    );
    assert_eq!(
        ::std::mem::align_of::<UCAN_Get_CAN_Status>(),
        4usize,
        concat!("Alignment of ", stringify!(UCAN_Get_CAN_Status))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UCAN_Get_CAN_Status>())).frame_type as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(UCAN_Get_CAN_Status),
            "::",
            stringify!(frame_type)
        )
    );
}
#[doc = " @brief UCAN_FD_RX frame structure"]
#[repr(C)]
#[derive(Copy, Clone, Serialize, Deserialize)] pub struct UCAN_RxFrameDef {
    #[doc = "< Frame type is @ref UCAN_FD_GET_STATUS."]
    pub frame_type: UCAN_FRAME_TYPE,
    #[doc = "< FDCAN Rx header structure definition @ref FDCAN_RxHeaderTypeDef."]
    pub can_rx_header: FDCAN_RxHeaderTypeDef,
     #[serde(with = "BigArray")]
 pub can_data: [u8; 64usize], 
    pub protocol_status: FDCAN_ProtocolStatusTypeDef,
    pub error_counters: FDCAN_ErrorCountersTypeDef,
}
#[test]
fn bindgen_test_layout_UCAN_RxFrameDef() {
    assert_eq!(
        ::std::mem::size_of::<UCAN_RxFrameDef>(),
        168usize,
        concat!("Size of: ", stringify!(UCAN_RxFrameDef))
    );
    assert_eq!(
        ::std::mem::align_of::<UCAN_RxFrameDef>(),
        4usize,
        concat!("Alignment of ", stringify!(UCAN_RxFrameDef))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UCAN_RxFrameDef>())).frame_type as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(UCAN_RxFrameDef),
            "::",
            stringify!(frame_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UCAN_RxFrameDef>())).can_rx_header as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(UCAN_RxFrameDef),
            "::",
            stringify!(can_rx_header)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UCAN_RxFrameDef>())).can_data as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(UCAN_RxFrameDef),
            "::",
            stringify!(can_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UCAN_RxFrameDef>())).protocol_status as *const _ as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(UCAN_RxFrameDef),
            "::",
            stringify!(protocol_status)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UCAN_RxFrameDef>())).error_counters as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(UCAN_RxFrameDef),
            "::",
            stringify!(error_counters)
        )
    );
}
#[doc = " @brief UCAN_FD_ACK frame structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Serialize, Deserialize)] pub struct UCAN_AckFrameDef {
    #[doc = "< Frame type is @ref UCAN_FD_GET_STATUS."]
    pub frame_type: UCAN_FRAME_TYPE,
    #[doc = "< Last command status @ref UCAN_FD_GET_STATUS."]
    pub cmd_status: UCAN_FRAME_CMD_STATUS,
    pub can_protocol_status: FDCAN_ProtocolStatusTypeDef,
    pub can_error_counters: FDCAN_ErrorCountersTypeDef,
    #[doc = "< FDCAN Init structure definition @ref FDCAN_InitTypeDef."]
    pub can_init_structure: FDCAN_InitTypeDef,
    pub dev_desc: FDCAN_Device_DescritionDef,
}
#[test]
fn bindgen_test_layout_UCAN_AckFrameDef() {
    assert_eq!(
        ::std::mem::size_of::<UCAN_AckFrameDef>(),
        152usize,
        concat!("Size of: ", stringify!(UCAN_AckFrameDef))
    );
    assert_eq!(
        ::std::mem::align_of::<UCAN_AckFrameDef>(),
        4usize,
        concat!("Alignment of ", stringify!(UCAN_AckFrameDef))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UCAN_AckFrameDef>())).frame_type as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(UCAN_AckFrameDef),
            "::",
            stringify!(frame_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UCAN_AckFrameDef>())).cmd_status as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(UCAN_AckFrameDef),
            "::",
            stringify!(cmd_status)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<UCAN_AckFrameDef>())).can_protocol_status as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(UCAN_AckFrameDef),
            "::",
            stringify!(can_protocol_status)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<UCAN_AckFrameDef>())).can_error_counters as *const _ as usize
        },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(UCAN_AckFrameDef),
            "::",
            stringify!(can_error_counters)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<UCAN_AckFrameDef>())).can_init_structure as *const _ as usize
        },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(UCAN_AckFrameDef),
            "::",
            stringify!(can_init_structure)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UCAN_AckFrameDef>())).dev_desc as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(UCAN_AckFrameDef),
            "::",
            stringify!(dev_desc)
        )
    );
}
